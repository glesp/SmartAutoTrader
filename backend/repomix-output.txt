This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.cs, **/*.ts, **/*.tsx, **/*.razor, **/*.py
- Files matching these patterns are excluded: **/wwwroot/**, **/public/**, **/*.sln, **/*.csproj, **/launchSettings.json, **/*.test.ts, **/__tests__/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Controllers/
  AuthController.cs
  ChatController.cs
  FavoritesController.cs
  InquiriesController.cs
  RecommendationsController.cs
  VehiclesController.cs
Data/
  ApplicationDbContext.cs
DataSeeding/
  VehicleSeederScript.cs
Helpers/
  EnumsHelper.cs
Migrations/
  20250311100503_InitialCreate.cs
  20250311100503_InitialCreate.Designer.cs
  20250317182424_AddChatHistory.cs
  20250317182424_AddChatHistory.Designer.cs
  20250326160742_AddConversationSessions.cs
  20250326160742_AddConversationSessions.Designer.cs
  ApplicationDbContextModelSnapshot.cs
Models/
  ChatHistory.cs
  Inquiry.cs
  LoginModel.cs
  RegisterModel.cs
  User.cs
  Vehicle.cs
obj/
  Debug/
    net8.0/
      .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
      SmartAutoTrader.API.AssemblyInfo.cs
      SmartAutoTrader.API.GlobalUsings.g.cs
      SmartAutoTrader.API.MvcApplicationPartsAssemblyInfo.cs
Services/
  AIServiceRegistration.cs
  AuthService.cs
  ChatRecommendationsService.cs
  ConversationContextService.cs
  HuggingFaceRecommendationsService.cs
  RecommendationParameters.cs
Validators/
  RecommendationParameterValidator.cs
Program.cs

================================================================
Files
================================================================

================
File: Controllers/AuthController.cs
================
public class AuthController(IAuthService authService) : ControllerBase
⋮----
private readonly IAuthService _authService = authService;
⋮----
public async Task<IActionResult> Register([FromBody] RegisterModel model)
⋮----
Models.User user = await _authService.RegisterAsync(
⋮----
public async Task<IActionResult> Login([FromBody] LoginModel model)
⋮----
(string token, Models.User user) = await _authService.LoginAsync(model.Email, model.Password);

================
File: Controllers/ChatController.cs
================
if (string.IsNullOrWhiteSpace(message.Content))
⋮----
// Get the user ID from the claims
Claim? userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out int userId))
⋮----
_logger.LogWarning("Failed to extract user ID from claims");
⋮----
_logger.LogInformation("Processing chat message from user ID: {UserId}", userId);
⋮----
// Check if we need to start a new conversation
if (!message.IsClarification && !message.IsFollowUp && string.IsNullOrEmpty(message.ConversationId))
⋮----
// Start a new conversation session
ConversationSession session = await _contextService.StartNewSessionAsync(userId);
message.ConversationId = session.Id.ToString();
⋮----
// Process the message
ChatMessage chatMessage = new ChatMessage
⋮----
ChatResponse response = await _chatService.ProcessMessageAsync(userId, chatMessage);
⋮----
// Check for null values to avoid NullReferenceException
⋮----
// Map the response to a DTO with null checks
ChatResponseDto responseDto = new ChatResponseDto
⋮----
? new RecommendationParametersDto
⋮----
?.Select(t => t.ToString())?.ToList(),
PreferredFuelTypes = response.UpdatedParameters.PreferredFuelTypes?.Select(f => f.ToString())
⋮----
_logger.LogError(ex, "Error processing chat message");
⋮----
// Get chat history from database
⋮----
.Where(ch => ch.UserId == userId);
⋮----
// Filter by conversationId if provided
if (!string.IsNullOrEmpty(conversationId) && int.TryParse(conversationId, out int convoId))
⋮----
query = query.Where(ch => ch.ConversationSessionId == convoId);
⋮----
.OrderByDescending(ch => ch.Timestamp)
.Take(limit)
.Select(ch => new ChatHistoryDto
⋮----
Timestamp = ch.Timestamp.ToString("o"),
ConversationId = ch.ConversationSessionId.ToString(),
⋮----
.ToListAsync();
⋮----
_logger.LogError(ex, "Error retrieving chat history");
⋮----
// Get recent conversations
⋮----
.Where(cs => cs.UserId == userId)
.OrderByDescending(cs => cs.LastInteractionAt)
⋮----
.Select(cs => new
⋮----
MessageCount = _context.ChatHistory.Count(ch => ch.ConversationSessionId == cs.Id),
⋮----
_logger.LogError(ex, "Error retrieving conversations");
⋮----
// Create a new conversation session
⋮----
_logger.LogError(ex, "Error starting new conversation");
⋮----
public RecommendationParametersDto Parameters { get; set; }

================
File: Controllers/FavoritesController.cs
================
public class FavoritesController(ApplicationDbContext context) : ControllerBase
⋮----
private readonly ApplicationDbContext _context = context;
⋮----
// GET: api/Favorites
⋮----
public async Task<ActionResult<IEnumerable<Vehicle>>> GetFavorites()
⋮----
int userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value);
⋮----
.Where(uf => uf.UserId == userId)
.Include(uf => uf.Vehicle)
.ThenInclude(v => v.Images)
.Select(uf => uf.Vehicle)
.ToListAsync();
⋮----
// POST: api/Favorites
⋮----
public async Task<IActionResult> AddFavorite(int vehicleId)
⋮----
// Check if vehicle exists
Vehicle? vehicle = await _context.Vehicles.FindAsync(vehicleId);
⋮----
// Check if already favorited
⋮----
.FirstOrDefaultAsync(uf => uf.UserId == userId && uf.VehicleId == vehicleId);
⋮----
// Add to favorites
UserFavorite favorite = new UserFavorite
⋮----
_ = _context.UserFavorites.Add(favorite);
_ = await _context.SaveChangesAsync();
⋮----
// DELETE: api/Favorites/5
⋮----
public async Task<IActionResult> RemoveFavorite(int vehicleId)
⋮----
_ = _context.UserFavorites.Remove(favorite);
⋮----
// GET: api/Favorites/Check/5
⋮----
public async Task<ActionResult<bool>> CheckFavorite(int vehicleId)
⋮----
.AnyAsync(uf => uf.UserId == userId && uf.VehicleId == vehicleId);
⋮----
// GET: api/Favorites/Count
⋮----
public async Task<ActionResult<int>> GetFavoritesCount()
⋮----
.CountAsync(uf => uf.UserId == userId);

================
File: Controllers/InquiriesController.cs
================
public class InquiriesController(ApplicationDbContext context) : ControllerBase
⋮----
private readonly ApplicationDbContext _context = context;
⋮----
// GET: api/Inquiries
⋮----
public async Task<ActionResult<IEnumerable<Inquiry>>> GetUserInquiries()
⋮----
int userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value);
⋮----
.Where(i => i.UserId == userId)
.Include(i => i.Vehicle)
.OrderByDescending(i => i.DateSent)
.ToListAsync();
⋮----
// GET: api/Inquiries/5
⋮----
public async Task<ActionResult<Inquiry>> GetInquiry(int id)
⋮----
.FirstOrDefaultAsync(i => i.Id == id && i.UserId == userId);
⋮----
// POST: api/Inquiries
⋮----
public async Task<ActionResult<Inquiry>> CreateInquiry(InquiryCreateDto inquiryDto)
⋮----
// Check if vehicle exists
Vehicle? vehicle = await _context.Vehicles.FindAsync(inquiryDto.VehicleId);
⋮----
Inquiry inquiry = new Inquiry
⋮----
_ = _context.Inquiries.Add(inquiry);
_ = await _context.SaveChangesAsync();
⋮----
// PUT: api/Inquiries/5/MarkAsRead
⋮----
[Authorize(Roles = "Admin")] // For admin access only
public async Task<IActionResult> MarkInquiryAsRead(int id)
⋮----
Inquiry? inquiry = await _context.Inquiries.FindAsync(id);
⋮----
_context.Entry(inquiry).State = EntityState.Modified;
⋮----
// PUT: api/Inquiries/5/Reply
⋮----
public async Task<IActionResult> ReplyToInquiry(int id, InquiryReplyDto replyDto)
⋮----
// PUT: api/Inquiries/5/Close
⋮----
public async Task<IActionResult> CloseInquiry(int id)
⋮----
private bool InquiryExists(int id)
⋮----
return _context.Inquiries.Any(e => e.Id == id);
⋮----
public class InquiryCreateDto
⋮----
public class InquiryReplyDto

================
File: Controllers/RecommendationsController.cs
================
[Authorize] // Requires authentication
⋮----
// Get user ID from claims
Claim? userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out int userId))
⋮----
// Convert request model to service parameters
RecommendationParameters parameters = new RecommendationParameters
⋮----
TextPrompt = request.TextPrompt, // Added text prompt
⋮----
// Log the text prompt for debugging
if (!string.IsNullOrEmpty(request.TextPrompt))
⋮----
_logger.LogInformation("Text prompt received: {TextPrompt}", request.TextPrompt);
⋮----
// Get recommendations from service
IEnumerable<Vehicle> recommendations = await _recommendationService.GetRecommendationsAsync(userId, parameters);
⋮----
// Return recommendations
⋮----
_logger.LogError(ex, "Error getting recommendations");
⋮----
// Endpoint for testing without authentication
⋮----
_logger.LogError(ex, "Error testing recommendations");
⋮----
public class RecommendationRequestModel
⋮----
public string? TextPrompt { get; set; } // Added text prompt

================
File: Controllers/VehiclesController.cs
================
public class VehiclesController(ApplicationDbContext context) : ControllerBase
⋮----
private readonly ApplicationDbContext _context = context;
⋮----
// GET: api/Vehicles
⋮----
public async Task<ActionResult<IEnumerable<Vehicle>>> GetVehicles(
⋮----
.Include(v => v.Images)
.Include(v => v.Features)
.Where(v => v.Status == VehicleStatus.Available);
⋮----
// Apply filters
if (!string.IsNullOrEmpty(make))
⋮----
query = query.Where(v => v.Make.Contains(make));
⋮----
if (!string.IsNullOrEmpty(model))
⋮----
query = query.Where(v => v.Model.Contains(model));
⋮----
query = query.Where(v => v.Year >= minYear.Value);
⋮----
query = query.Where(v => v.Year <= maxYear.Value);
⋮----
query = query.Where(v => v.Price >= minPrice.Value);
⋮----
query = query.Where(v => v.Price <= maxPrice.Value);
⋮----
query = query.Where(v => v.FuelType == fuelType.Value);
⋮----
query = query.Where(v => v.Transmission == transmission.Value);
⋮----
query = query.Where(v => v.VehicleType == vehicleType.Value);
⋮----
query = query.Where(v => v.Mileage >= minMileage.Value);
⋮----
query = query.Where(v => v.Mileage <= maxMileage.Value);
⋮----
// Apply sorting
query = sortBy.ToLower(System.Globalization.CultureInfo.CurrentCulture) switch
⋮----
"price" => ascending ? query.OrderBy(v => v.Price) : query.OrderByDescending(v => v.Price),
"year" => ascending ? query.OrderBy(v => v.Year) : query.OrderByDescending(v => v.Year),
"mileage" => ascending ? query.OrderBy(v => v.Mileage) : query.OrderByDescending(v => v.Mileage),
"make" => ascending ? query.OrderBy(v => v.Make) : query.OrderByDescending(v => v.Make),
"model" => ascending ? query.OrderBy(v => v.Model) : query.OrderByDescending(v => v.Model),
_ => ascending ? query.OrderBy(v => v.DateListed) : query.OrderByDescending(v => v.DateListed),
⋮----
// Apply pagination
int totalItems = await query.CountAsync();
int totalPages = (int)Math.Ceiling(totalItems / (double)pageSize);
⋮----
.Skip((pageNumber - 1) * pageSize)
.Take(pageSize)
.ToListAsync();
⋮----
// Add pagination headers
Response.Headers.Append("X-Total-Count", totalItems.ToString());
Response.Headers.Append("X-Total-Pages", totalPages.ToString());
⋮----
// GET: api/Vehicles/5
⋮----
public async Task<ActionResult<Vehicle>> GetVehicle(int id)
⋮----
.FirstOrDefaultAsync(v => v.Id == id);
⋮----
// Record viewing in browsing history if user is authenticated
⋮----
int userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value);
⋮----
BrowsingHistory history = new BrowsingHistory
⋮----
ViewDurationSeconds = 0, // Can be updated later
⋮----
_ = _context.BrowsingHistory.Add(history);
_ = await _context.SaveChangesAsync();
⋮----
// POST: api/Vehicles
⋮----
[Authorize] // Only authenticated users can add vehicles (in your case, admins)
public async Task<ActionResult<Vehicle>> PostVehicle(Vehicle vehicle)
⋮----
_ = _context.Vehicles.Add(vehicle);
⋮----
// PUT: api/Vehicles/5
⋮----
public async Task<IActionResult> PutVehicle(int id, Vehicle vehicle)
⋮----
_context.Entry(vehicle).State = EntityState.Modified;
⋮----
// DELETE: api/Vehicles/5
⋮----
public async Task<IActionResult> DeleteVehicle(int id)
⋮----
Vehicle? vehicle = await _context.Vehicles.FindAsync(id);
⋮----
_ = _context.Vehicles.Remove(vehicle);
⋮----
private bool VehicleExists(int id)
⋮----
return _context.Vehicles.Any(e => e.Id == id);
⋮----
public IActionResult GetAvailableMakes()
⋮----
.Select(v => v.Make)
.Distinct()
.OrderBy(m => m)
.ToList();
⋮----
public IActionResult GetAvailableModels([FromQuery] string make)
⋮----
.Where(v => v.Make == make)
.Select(v => v.Model)
⋮----
public IActionResult GetYearRange()
⋮----
int minYear = _context.Vehicles.Min(v => v.Year);
int maxYear = _context.Vehicles.Max(v => v.Year);

================
File: Data/ApplicationDbContext.cs
================
protected override void OnModelCreating(ModelBuilder modelBuilder)
⋮----
base.OnModelCreating(modelBuilder);
⋮----
// Configure relationships
⋮----
// Vehicle - VehicleImage (one-to-many)
⋮----
.HasOne(vi => vi.Vehicle)
.WithMany(v => v.Images)
.HasForeignKey(vi => vi.VehicleId);
⋮----
// Vehicle - VehicleFeature (one-to-many)
⋮----
.HasOne(vf => vf.Vehicle)
.WithMany(v => v.Features)
.HasForeignKey(vf => vf.VehicleId);
⋮----
// User - UserFavorite (one-to-many)
⋮----
.HasOne(uf => uf.User)
.WithMany(u => u.Favorites)
.HasForeignKey(uf => uf.UserId);
⋮----
// Vehicle - UserFavorite (one-to-many)
⋮----
.HasOne(uf => uf.Vehicle)
.WithMany(v => v.FavoritedBy)
.HasForeignKey(uf => uf.VehicleId);
⋮----
// User - UserPreference (one-to-many)
⋮----
.HasOne(up => up.User)
.WithMany(u => u.Preferences)
.HasForeignKey(up => up.UserId);
⋮----
// User - BrowsingHistory (one-to-many)
⋮----
.HasOne(bh => bh.User)
.WithMany(u => u.BrowsingHistory)
.HasForeignKey(bh => bh.UserId);
⋮----
// Vehicle - BrowsingHistory (one-to-many)
⋮----
.HasOne(bh => bh.Vehicle)
.WithMany()
.HasForeignKey(bh => bh.VehicleId);
⋮----
// User - Inquiry (one-to-many)
⋮----
.HasOne(i => i.User)
.WithMany(u => u.SentInquiries)
.HasForeignKey(i => i.UserId);
⋮----
// Vehicle - Inquiry (one-to-many)
⋮----
.HasOne(i => i.Vehicle)
⋮----
.HasForeignKey(i => i.VehicleId);
⋮----
// User - ChatHistory (one-to-many)
⋮----
.HasOne(ch => ch.User)
⋮----
.HasForeignKey(ch => ch.UserId);
⋮----
.HasOne(cs => cs.User)
⋮----
.HasForeignKey(cs => cs.UserId);
⋮----
.HasMany(cs => cs.Messages)
.WithOne(ch => ch.Session)
.HasForeignKey(ch => ch.ConversationSessionId)
.IsRequired(false); // Make the relationship optional

================
File: DataSeeding/VehicleSeederScript.cs
================
// Updated VehicleSeeder with local image mapping
⋮----
public class VehicleSeeder
⋮----
public void SeedVehicles(IServiceProvider serviceProvider, int count = 200)
⋮----
using IServiceScope scope = serviceProvider.CreateScope();
ApplicationDbContext context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
⋮----
if (!context.Vehicles.Any())
⋮----
context.Vehicles.AddRange(vehicles);
_ = context.SaveChanges();
Console.WriteLine($"Added {count} vehicles to the database.");
⋮----
Console.WriteLine("Database already contains vehicles. Skipping seed.");
⋮----
private static List<Vehicle> GenerateVehicles(int count)
⋮----
Random random = new Random();
⋮----
string make = makes[random.Next(makes.Length)];
string model = modelsByMake[make][random.Next(modelsByMake[make].Length)];
int year = random.Next(2010, 2026);
⋮----
(VehicleType vType, FuelType fType) = ModelMeta.TryGetValue(model, out (VehicleType, FuelType) value) ? value : ((VehicleType)random.Next(Enum.GetValues(typeof(VehicleType)).Length),
(FuelType)random.Next(Enum.GetValues(typeof(FuelType)).Length));
⋮----
string slug = $"{make}-{model}".Replace(" ", "").ToLower(System.Globalization.CultureInfo.CurrentCulture);
⋮----
Vehicle vehicle = new Vehicle
⋮----
Price = random.Next(5000, 100001),
Mileage = year == 2025 ? random.Next(0, 1000) : random.Next(1000, 150001),
⋮----
Transmission = (TransmissionType)random.Next(Enum.GetValues(typeof(TransmissionType)).Length),
⋮----
EngineSize = Math.Round((random.NextDouble() * 4) + 1, 1),
HorsePower = random.Next(100, 601),
⋮----
DateListed = DateTime.Now.AddDays(-random.Next(1, 60)),
⋮----
Features = featuresList.OrderBy(_ => random.Next()).Take(random.Next(3, 9))
.Select(f => new VehicleFeature { Name = f }).ToList(),
⋮----
vehicles.Add(vehicle);
⋮----
private static string GetCountryForMake(string make)
⋮----
private static VehicleStatus GetRandomStatusWithWeights(Random random)
⋮----
return random.Next(100) switch
⋮----
private static string GenerateDescription(string make, string model, int year)
⋮----
return descriptions[new Random().Next(descriptions.Length)];

================
File: Helpers/EnumsHelper.cs
================
public static class EnumHelpers
⋮----
public static bool TryParseFuelType(string value, out FuelType result)
⋮----
if (string.IsNullOrEmpty(value))
⋮----
// Try standard parsing first (case-insensitive)
if (Enum.TryParse(value, true, out result))
⋮----
// Additional fuzzy matching for common terms
switch (value.ToLower(System.Globalization.CultureInfo.CurrentCulture).Trim())
⋮----
public static bool TryParseVehicleType(string value, out VehicleType result)
⋮----
public static List<FuelType> ParseFuelTypeList(IEnumerable<string> values)
⋮----
result.Add(fuelType);
⋮----
public static List<VehicleType> ParseVehicleTypeList(IEnumerable<string> values)
⋮----
result.Add(vehicleType);

================
File: Migrations/20250311100503_InitialCreate.cs
================
/// <inheritdoc />
public partial class InitialCreate : Migration
⋮----
protected override void Up(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.CreateTable(
⋮----
.Annotation("Sqlite:Autoincrement", true),
⋮----
_ = table.PrimaryKey("PK_Users", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_Vehicles", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_UserPreferences", x => x.Id);
_ = table.ForeignKey(
⋮----
_ = table.PrimaryKey("PK_BrowsingHistory", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_Inquiries", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_UserFavorites", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_VehicleFeatures", x => x.Id);
⋮----
_ = table.PrimaryKey("PK_VehicleImages", x => x.Id);
⋮----
_ = migrationBuilder.CreateIndex(
⋮----
protected override void Down(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.DropTable(

================
File: Migrations/20250311100503_InitialCreate.Designer.cs
================
// <auto-generated />
⋮----
partial class InitialCreate
⋮----
/// <inheritdoc />
protected override void BuildTargetModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.3");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.BrowsingHistory", b =>
⋮----
.ValueGeneratedOnAdd()
.HasColumnType("INTEGER");
⋮----
.HasColumnType("TEXT");
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("UserId");
⋮----
b.HasIndex("VehicleId");
⋮----
b.ToTable("BrowsingHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Inquiry", b =>
⋮----
.IsRequired()
⋮----
b.ToTable("Inquiries");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.User", b =>
⋮----
b.ToTable("Users");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserFavorite", b =>
⋮----
b.ToTable("UserFavorites");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserPreference", b =>
⋮----
.HasColumnType("REAL");
⋮----
b.ToTable("UserPreferences");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Vehicle", b =>
⋮----
b.ToTable("Vehicles");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleFeature", b =>
⋮----
b.ToTable("VehicleFeatures");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleImage", b =>
⋮----
b.ToTable("VehicleImages");
⋮----
b.HasOne("SmartAutoTrader.API.Models.User", "User")
.WithMany("BrowsingHistory")
.HasForeignKey("UserId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("SmartAutoTrader.API.Models.Vehicle", "Vehicle")
.WithMany()
.HasForeignKey("VehicleId")
⋮----
b.Navigation("User");
⋮----
b.Navigation("Vehicle");
⋮----
.WithMany("SentInquiries")
⋮----
.WithMany("Favorites")
⋮----
.WithMany("FavoritedBy")
⋮----
.WithMany("Preferences")
⋮----
.WithMany("Features")
⋮----
.WithMany("Images")
⋮----
b.Navigation("BrowsingHistory");
⋮----
b.Navigation("Favorites");
⋮----
b.Navigation("Preferences");
⋮----
b.Navigation("SentInquiries");
⋮----
b.Navigation("FavoritedBy");
⋮----
b.Navigation("Features");
⋮----
b.Navigation("Images");

================
File: Migrations/20250317182424_AddChatHistory.cs
================
/// <inheritdoc />
public partial class AddChatHistory : Migration
⋮----
protected override void Up(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.CreateTable(
⋮----
.Annotation("Sqlite:Autoincrement", true),
⋮----
_ = table.PrimaryKey("PK_ChatHistory", x => x.Id);
_ = table.ForeignKey(
⋮----
_ = migrationBuilder.CreateIndex(
⋮----
protected override void Down(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.DropTable(

================
File: Migrations/20250317182424_AddChatHistory.Designer.cs
================
// <auto-generated />
⋮----
partial class AddChatHistory
⋮----
/// <inheritdoc />
protected override void BuildTargetModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.3");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.BrowsingHistory", b =>
⋮----
.ValueGeneratedOnAdd()
.HasColumnType("INTEGER");
⋮----
.HasColumnType("TEXT");
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("UserId");
⋮----
b.HasIndex("VehicleId");
⋮----
b.ToTable("BrowsingHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.ChatHistory", b =>
⋮----
.IsRequired()
⋮----
b.ToTable("ChatHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Inquiry", b =>
⋮----
b.ToTable("Inquiries");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.User", b =>
⋮----
b.ToTable("Users");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserFavorite", b =>
⋮----
b.ToTable("UserFavorites");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserPreference", b =>
⋮----
.HasColumnType("REAL");
⋮----
b.ToTable("UserPreferences");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Vehicle", b =>
⋮----
b.ToTable("Vehicles");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleFeature", b =>
⋮----
b.ToTable("VehicleFeatures");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleImage", b =>
⋮----
b.ToTable("VehicleImages");
⋮----
b.HasOne("SmartAutoTrader.API.Models.User", "User")
.WithMany("BrowsingHistory")
.HasForeignKey("UserId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("SmartAutoTrader.API.Models.Vehicle", "Vehicle")
.WithMany()
.HasForeignKey("VehicleId")
⋮----
b.Navigation("User");
⋮----
b.Navigation("Vehicle");
⋮----
.WithMany("SentInquiries")
⋮----
.WithMany("Favorites")
⋮----
.WithMany("FavoritedBy")
⋮----
.WithMany("Preferences")
⋮----
.WithMany("Features")
⋮----
.WithMany("Images")
⋮----
b.Navigation("BrowsingHistory");
⋮----
b.Navigation("Favorites");
⋮----
b.Navigation("Preferences");
⋮----
b.Navigation("SentInquiries");
⋮----
b.Navigation("FavoritedBy");
⋮----
b.Navigation("Features");
⋮----
b.Navigation("Images");

================
File: Migrations/20250326160742_AddConversationSessions.cs
================
/// <inheritdoc />
public partial class AddConversationSessions : Migration
⋮----
protected override void Up(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.CreateTable(
⋮----
.Annotation("Sqlite:Autoincrement", true),
⋮----
_ = table.PrimaryKey("PK_ConversationSessions", x => x.Id);
_ = table.ForeignKey(
⋮----
_ = migrationBuilder.CreateIndex(
⋮----
_ = migrationBuilder.AddForeignKey(
⋮----
protected override void Down(MigrationBuilder migrationBuilder)
⋮----
_ = migrationBuilder.DropForeignKey(
⋮----
_ = migrationBuilder.DropTable(
⋮----
_ = migrationBuilder.DropIndex(
⋮----
_ = migrationBuilder.DropColumn(

================
File: Migrations/20250326160742_AddConversationSessions.Designer.cs
================
// <auto-generated />
⋮----
partial class AddConversationSessions
⋮----
/// <inheritdoc />
protected override void BuildTargetModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.3");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.BrowsingHistory", b =>
⋮----
.ValueGeneratedOnAdd()
.HasColumnType("INTEGER");
⋮----
.HasColumnType("TEXT");
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("UserId");
⋮----
b.HasIndex("VehicleId");
⋮----
b.ToTable("BrowsingHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.ChatHistory", b =>
⋮----
.IsRequired()
⋮----
b.HasIndex("ConversationSessionId");
⋮----
b.ToTable("ChatHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.ConversationSession", b =>
⋮----
b.ToTable("ConversationSessions");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Inquiry", b =>
⋮----
b.ToTable("Inquiries");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.User", b =>
⋮----
b.ToTable("Users");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserFavorite", b =>
⋮----
b.ToTable("UserFavorites");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserPreference", b =>
⋮----
.HasColumnType("REAL");
⋮----
b.ToTable("UserPreferences");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Vehicle", b =>
⋮----
b.ToTable("Vehicles");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleFeature", b =>
⋮----
b.ToTable("VehicleFeatures");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleImage", b =>
⋮----
b.ToTable("VehicleImages");
⋮----
b.HasOne("SmartAutoTrader.API.Models.User", "User")
.WithMany("BrowsingHistory")
.HasForeignKey("UserId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("SmartAutoTrader.API.Models.Vehicle", "Vehicle")
.WithMany()
.HasForeignKey("VehicleId")
⋮----
b.Navigation("User");
⋮----
b.Navigation("Vehicle");
⋮----
b.HasOne("SmartAutoTrader.API.Models.ConversationSession", "Session")
.WithMany("Messages")
.HasForeignKey("ConversationSessionId");
⋮----
b.Navigation("Session");
⋮----
.WithMany("SentInquiries")
⋮----
.WithMany("Favorites")
⋮----
.WithMany("FavoritedBy")
⋮----
.WithMany("Preferences")
⋮----
.WithMany("Features")
⋮----
.WithMany("Images")
⋮----
b.Navigation("Messages");
⋮----
b.Navigation("BrowsingHistory");
⋮----
b.Navigation("Favorites");
⋮----
b.Navigation("Preferences");
⋮----
b.Navigation("SentInquiries");
⋮----
b.Navigation("FavoritedBy");
⋮----
b.Navigation("Features");
⋮----
b.Navigation("Images");

================
File: Migrations/ApplicationDbContextModelSnapshot.cs
================
// <auto-generated />
⋮----
partial class ApplicationDbContextModelSnapshot : ModelSnapshot
⋮----
protected override void BuildModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.3");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.BrowsingHistory", b =>
⋮----
.ValueGeneratedOnAdd()
.HasColumnType("INTEGER");
⋮----
.HasColumnType("TEXT");
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("UserId");
⋮----
b.HasIndex("VehicleId");
⋮----
b.ToTable("BrowsingHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.ChatHistory", b =>
⋮----
.IsRequired()
⋮----
b.HasIndex("ConversationSessionId");
⋮----
b.ToTable("ChatHistory");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.ConversationSession", b =>
⋮----
b.ToTable("ConversationSessions");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Inquiry", b =>
⋮----
b.ToTable("Inquiries");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.User", b =>
⋮----
b.ToTable("Users");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserFavorite", b =>
⋮----
b.ToTable("UserFavorites");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.UserPreference", b =>
⋮----
.HasColumnType("REAL");
⋮----
b.ToTable("UserPreferences");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.Vehicle", b =>
⋮----
b.ToTable("Vehicles");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleFeature", b =>
⋮----
b.ToTable("VehicleFeatures");
⋮----
modelBuilder.Entity("SmartAutoTrader.API.Models.VehicleImage", b =>
⋮----
b.ToTable("VehicleImages");
⋮----
b.HasOne("SmartAutoTrader.API.Models.User", "User")
.WithMany("BrowsingHistory")
.HasForeignKey("UserId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("SmartAutoTrader.API.Models.Vehicle", "Vehicle")
.WithMany()
.HasForeignKey("VehicleId")
⋮----
b.Navigation("User");
⋮----
b.Navigation("Vehicle");
⋮----
b.HasOne("SmartAutoTrader.API.Models.ConversationSession", "Session")
.WithMany("Messages")
.HasForeignKey("ConversationSessionId");
⋮----
b.Navigation("Session");
⋮----
.WithMany("SentInquiries")
⋮----
.WithMany("Favorites")
⋮----
.WithMany("FavoritedBy")
⋮----
.WithMany("Preferences")
⋮----
.WithMany("Features")
⋮----
.WithMany("Images")
⋮----
b.Navigation("Messages");
⋮----
b.Navigation("BrowsingHistory");
⋮----
b.Navigation("Favorites");
⋮----
b.Navigation("Preferences");
⋮----
b.Navigation("SentInquiries");
⋮----
b.Navigation("FavoritedBy");
⋮----
b.Navigation("Features");
⋮----
b.Navigation("Images");

================
File: Models/ChatHistory.cs
================
public class ChatHistory
⋮----
public class ConversationSession
⋮----
public string SessionContext { get; set; } // JSON string to store conversation context

================
File: Models/Inquiry.cs
================
public class Inquiry

================
File: Models/LoginModel.cs
================
// Models/LoginModel.cs
⋮----
public class LoginModel

================
File: Models/RegisterModel.cs
================
// Models/RegisterModel.cs
⋮----
public class RegisterModel

================
File: Models/User.cs
================
public class User
⋮----
// Navigation properties
⋮----
public class UserFavorite
⋮----
public class UserPreference
⋮----
public string PreferenceType { get; set; } // e.g., "PriceRange", "VehicleType", "FuelType"
⋮----
public string Value { get; set; } // Store as JSON if needed for complex values
⋮----
public float Weight { get; set; } = 1.0f; // Default weight = 1
⋮----
public class BrowsingHistory

================
File: Models/Vehicle.cs
================
public class Vehicle
⋮----
// Navigation properties
⋮----
public class VehicleImage
⋮----
public class VehicleFeature

================
File: obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================
// <autogenerated />

================
File: obj/Debug/net8.0/SmartAutoTrader.API.AssemblyInfo.cs
================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
⋮----
// Generated by the MSBuild WriteCodeFragment class.

================
File: obj/Debug/net8.0/SmartAutoTrader.API.GlobalUsings.g.cs
================
// <auto-generated/>

================
File: obj/Debug/net8.0/SmartAutoTrader.API.MvcApplicationPartsAssemblyInfo.cs
================
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
⋮----
// Generated by the MSBuild WriteCodeFragment class.

================
File: Services/AIServiceRegistration.cs
================
public static class AIServiceRegistration
⋮----
public static IServiceCollection AddAIRecommendationServices(
⋮----
// Register HttpClient for API calls
_ = services.AddHttpClient();
⋮----
// Determine which AI provider to use based on configuration
⋮----
// If you implement OpenAI in the future
// services.AddScoped<IAIRecommendationService, OpenAIRecommendationService>();
throw new NotImplementedException("OpenAI provider not yet implemented");
⋮----
// For a simple fallback without AI, implement a FallbackRecommendationService
// services.AddScoped<IAIRecommendationService, FallbackRecommendationService>();
throw new NotImplementedException("Fallback provider not yet implemented");
⋮----
// Default to Hugging Face

================
File: Services/AuthService.cs
================
public interface IAuthService
⋮----
Task<User> RegisterAsync(string username, string email, string password, string firstName, string lastName,
⋮----
Task<(string token, User user)> LoginAsync(string email, string password);
⋮----
string GenerateJwtToken(User user);
⋮----
// Check if user already exists
if (await _context.Users.AnyAsync(u => u.Email == email || u.Username == username))
⋮----
throw new Exception("User with this email or username already exists.");
⋮----
// Create new user
User user = new User
⋮----
PasswordHash = BC.HashPassword(password),
⋮----
_ = _context.Users.Add(user);
_ = await _context.SaveChangesAsync();
⋮----
// Find user by email
User? user = await _context.Users.FirstOrDefaultAsync(u => u.Email == email);
⋮----
// Check if user exists and password is correct
if (user == null || !BC.Verify(password, user.PasswordHash))
⋮----
throw new Exception("Invalid email or password.");
⋮----
// Generate JWT token
⋮----
byte[] key = Encoding.ASCII.GetBytes(_configuration["Jwt:Key"]);
⋮----
SecurityTokenDescriptor tokenDescriptor = new SecurityTokenDescriptor
⋮----
Subject = new ClaimsIdentity(new[]
⋮----
new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
new Claim(ClaimTypes.Name, user.Username),
new Claim(ClaimTypes.Email, user.Email),
⋮----
Expires = DateTime.UtcNow.AddDays(7),
⋮----
new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature),
⋮----
JwtSecurityTokenHandler tokenHandler = new JwtSecurityTokenHandler();
SecurityToken token = tokenHandler.CreateToken(tokenDescriptor);
⋮----
return tokenHandler.WriteToken(token);

================
File: Services/ChatRecommendationsService.cs
================
public interface IChatRecommendationService
⋮----
Task<ChatResponse> ProcessMessageAsync(int userId, ChatMessage message);
⋮----
public class ChatMessage
⋮----
public class ChatResponse
⋮----
_logger.LogInformation("Processing chat message for user ID: {UserId}", userId);
⋮----
// Get or create conversation session ID
⋮----
if (!string.IsNullOrEmpty(message.ConversationId) &&
int.TryParse(message.ConversationId, out int sessionId))
⋮----
_logger.LogInformation("Using existing conversation session: {SessionId}", sessionId);
⋮----
// Get conversation context
ConversationContext conversationContext = await _contextService.GetOrCreateContextAsync(userId);
⋮----
// Update conversation context with basic tracking info
⋮----
// Get user context for personalization
⋮----
.Include(u => u.Preferences)
.FirstOrDefaultAsync(u => u.Id == userId);
⋮----
_logger.LogWarning("User with ID {UserId} not found", userId);
return new ChatResponse
⋮----
// Load related entities separately
⋮----
.Where(f => f.UserId == userId)
.Include(f => f.Vehicle)
.ToListAsync();
⋮----
.Where(h => h.UserId == userId)
.OrderByDescending(h => h.ViewDate)
.Take(5)
.Include(h => h.Vehicle)
⋮----
// Determine if this is a clarification or a follow-up query
⋮----
// Check for conversation continuity
⋮----
if (message.IsClarification && !string.IsNullOrEmpty(message.OriginalUserInput))
⋮----
// Combine original query with clarification
⋮----
_logger.LogInformation("Processing clarification. Combined message: {Message}", messageToProcess);
⋮----
// This is a follow-up to the previous query, use the context
⋮----
_logger.LogInformation("Processing follow-up query. Combined message: {Message}", messageToProcess);
⋮----
// Analyze message for features or preferences
⋮----
_logger.LogInformation(
⋮----
Stopwatch sw = Stopwatch.StartNew();
RecommendationParameters extractedParameters = await ExtractParametersAsync(messageToProcess);
sw.Stop();
⋮----
_logger.LogInformation("⏱️ LLM extraction took {ElapsedMs}ms", sw.ElapsedMilliseconds);
⋮----
_logger.LogError(
⋮----
_logger.LogError("[LLM_NULL_PARAMETERS] User message: {Message}", messageToProcess);
⋮----
UpdatedParameters = conversationContext.CurrentParameters ?? new RecommendationParameters(),
⋮----
if (extractedParameters.IsOffTopic && !string.IsNullOrEmpty(extractedParameters.OffTopicResponse))
⋮----
// Return the off-topic response directly without further processing
⋮----
UpdatedParameters = new RecommendationParameters(),
⋮----
_logger.LogInformation("Parameter extraction completed successfully");
⋮----
// Merge with existing parameters if this is a follow-up or clarification
RecommendationParameters parameters;
⋮----
_logger.LogInformation("Merged parameters from context and new extraction");
⋮----
// Store the original message as last user intent
⋮----
// Update the conversation context with new parameters
⋮----
// Save context
await _contextService.UpdateContextAsync(userId, conversationContext);
⋮----
// Determine if we need further clarification based on parameters
⋮----
_logger.LogInformation("Clarification needed for user query");
⋮----
// Create clarification message based on context
⋮----
// Save the chat history
⋮----
// This is either a complete initial query or a follow-up clarification
⋮----
_logger.LogInformation("Using parameters: {@Parameters}", parameters);
⋮----
// Save the chat history with a placeholder response
⋮----
// Get recommendations based on the parameters
IEnumerable<Vehicle> recommendations = await _recommendationService.GetRecommendationsAsync(userId, parameters);
⋮----
// Track which vehicles were shown to the user
List<int> vehicleIds = recommendations.Select(v => v.Id).ToList();
⋮----
if (!conversationContext.ShownVehicleIds.Contains(id))
⋮----
conversationContext.ShownVehicleIds.Add(id);
⋮----
// Save the updated context with shown vehicles
⋮----
// Generate a response based on the parameters, recommendations, and context
string responseMessage = GenerateResponseMessage(parameters, recommendations.Count(), conversationContext);
⋮----
RecommendedVehicles = recommendations.ToList(),
⋮----
_logger.LogError(ex, "Error processing chat message for user ID {UserId}", userId);
⋮----
// Determine if a message is a follow-up to the previous conversation
⋮----
// If this is the first message in the conversation, it's not a follow-up
if (context.MessageCount <= 1 || string.IsNullOrEmpty(context.LastUserIntent))
⋮----
// Check if the message is short (likely to be a follow-up)
if (message.Split(' ').Length <= 4)
⋮----
// Check for follow-up indicators
string lowerMessage = message.ToLower(System.Globalization.CultureInfo.CurrentCulture);
⋮----
if (followUpIndicators.Any(lowerMessage.Contains))
⋮----
// Check for pronouns that might refer to previous context
⋮----
if (contextualPronouns.Any(pronoun => lowerMessage.Contains($" {pronoun} ")))
⋮----
// If the last interaction was recent (< 2 minutes ago), more likely to be a follow-up
⋮----
// Apply more relaxed criteria for recent interactions
⋮----
// Save chat history to the database
⋮----
// Create a chat history record
ChatHistory chatHistory = new ChatHistory
⋮----
_ = _context.ChatHistory.Add(chatHistory);
_ = await _context.SaveChangesAsync();
⋮----
_logger.LogError(ex, "Error saving chat history for user ID {UserId}", userId);
⋮----
// Continue even if saving history fails
⋮----
// Update context based on message content
⋮----
if (lowerMessage.Contains(feature) && !context.MentionedVehicleFeatures.Contains(feature))
⋮----
context.MentionedVehicleFeatures.Add(feature);
⋮----
// Detect explicitly rejected options
if (lowerMessage.Contains("not ") || lowerMessage.Contains("don't want") ||
lowerMessage.Contains("no ") || lowerMessage.Contains("except"))
⋮----
if ((lowerMessage.Contains($"not {make}") || lowerMessage.Contains($"no {make}")) &&
!context.ExplicitlyRejectedOptions.Contains(make))
⋮----
context.ExplicitlyRejectedOptions.Add(make);
⋮----
// Track topic context (for conversation flow management)
if (lowerMessage.Contains("budget") || lowerMessage.Contains("price") ||
lowerMessage.Contains("cost") || lowerMessage.Contains("afford"))
⋮----
if (lowerMessage.Contains("family") || lowerMessage.Contains("kids") ||
lowerMessage.Contains("children") || lowerMessage.Contains("baby"))
⋮----
if (lowerMessage.Contains("fuel") || lowerMessage.Contains("gas") ||
lowerMessage.Contains("diesel") || lowerMessage.Contains("electric") ||
lowerMessage.Contains("economy") || lowerMessage.Contains("consumption"))
⋮----
// Merge parameters from a new query with existing parameters from context
⋮----
// Start with the new parameters
RecommendationParameters mergedParams = newParams;
⋮----
// For each field, prefer new values if present, otherwise keep the existing ones
⋮----
// Price range
⋮----
// Year range
⋮----
// Vehicle types (if new ones are specified, use those; otherwise keep existing)
if (mergedParams.PreferredVehicleTypes == null || !mergedParams.PreferredVehicleTypes.Any())
⋮----
// Makes (same logic as vehicle types)
if (mergedParams.PreferredMakes == null || !mergedParams.PreferredMakes.Any())
⋮----
// Fuel types
if (mergedParams.PreferredFuelTypes == null || !mergedParams.PreferredFuelTypes.Any())
⋮----
// Features
if (mergedParams.DesiredFeatures == null || !mergedParams.DesiredFeatures.Any())
⋮----
// Max mileage
⋮----
// This method determines if we need clarification based on the extracted parameters
⋮----
// Count how many parameter types are missing
⋮----
// Check if essential parameters are missing
⋮----
if ((parameters.PreferredVehicleTypes == null || !parameters.PreferredVehicleTypes.Any()) &&
!message.Contains("any type", StringComparison.CurrentCultureIgnoreCase) && !message.Contains("any vehicle", StringComparison.CurrentCultureIgnoreCase))
⋮----
if ((parameters.PreferredMakes == null || !parameters.PreferredMakes.Any()) &&
!message.Contains("any make", StringComparison.CurrentCultureIgnoreCase) && !message.Contains("any brand", StringComparison.CurrentCultureIgnoreCase))
⋮----
// same for year
⋮----
// same for mileage
⋮----
// same for preferred fuel type
if (parameters.PreferredFuelTypes == null || !parameters.PreferredFuelTypes.Any())
⋮----
// Ask for clarification is more than 3 parameter types are missing
⋮----
// Generate a personalized clarification message based on context
⋮----
StringBuilder clarification = new StringBuilder();
⋮----
// If this is a follow-up question, acknowledge the previous context
⋮----
_ = clarification.Append("Building on our previous conversation, ");
⋮----
_ = clarification.Append("I'd like to help you find the perfect vehicle, but I need a bit more information. ");
⋮----
// Ask about missing parameters, considering context
⋮----
if (context.TopicContext.ContainsKey("discussing_budget"))
⋮----
_ = clarification.Append("Could you provide a specific price range you're comfortable with? ");
⋮----
_ = clarification.Append("What's your budget range for this vehicle? ");
⋮----
if (parameters.PreferredVehicleTypes == null || !parameters.PreferredVehicleTypes.Any())
⋮----
if (context.TopicContext.ContainsKey("discussing_family_needs"))
⋮----
_ = clarification.Append(
⋮----
_ = clarification.Append("What type of vehicle are you interested in (sedan, SUV, hatchback, etc.)? ");
⋮----
if (parameters.PreferredMakes == null || !parameters.PreferredMakes.Any())
⋮----
// Check if user has rejected any makes
if (context.ExplicitlyRejectedOptions.Any())
⋮----
$"You mentioned you don't want {string.Join(", ", context.ExplicitlyRejectedOptions)}. Are there any specific makes you're interested in instead? ");
⋮----
_ = clarification.Append("Do you have any preferred manufacturers or brands? ");
⋮----
_ = clarification.Append("How new would you like the vehicle to be? ");
⋮----
_ = clarification.Append("The more details you can provide, the better I can match you with the right vehicle.");
⋮----
return clarification.ToString();
⋮----
// Generate a personalized response message based on context
⋮----
StringBuilder response = new StringBuilder();
⋮----
_ = response.Append("I couldn't find any vehicles matching all your criteria. ");
⋮----
// Suggest relaxing constraints based on context
⋮----
_ = response.Append("Consider broadening your price range. ");
⋮----
_ = response.Append("Try including more manufacturers in your search. ");
⋮----
_ = response.Append("Consider exploring different vehicle types. ");
⋮----
return response.ToString();
⋮----
// Personalize based on conversation history
⋮----
_ = response.Append("Based on our conversation, ");
⋮----
_ = response.Append($"I found {recommendationCount} vehicles that match your preferences. ");
⋮----
// Add details about what was matched
⋮----
_ = response.Append($"Vehicle type: {string.Join(", ", parameters.PreferredVehicleTypes)}. ");
⋮----
_ = response.Append($"Make: {string.Join(", ", parameters.PreferredMakes)}. ");
⋮----
_ = response.Append("Price range: ");
⋮----
_ = response.Append($"€{parameters.MinPrice:N0} ");
⋮----
_ = response.Append("to ");
⋮----
_ = response.Append($"€{parameters.MaxPrice:N0}. ");
⋮----
_ = response.Append("any. ");
⋮----
_ = response.Append("Year: ");
⋮----
_ = response.Append($"{parameters.MinYear} ");
⋮----
_ = response.Append($"{parameters.MaxYear}. ");
⋮----
_ = response.Append("present. ");
⋮----
// Add personalized guidance based on context
⋮----
_ = response.Append("These options should provide good space and safety features for your family needs. ");
⋮----
if (context.TopicContext.ContainsKey("discussing_fuel_economy"))
⋮----
_ = response.Append("I've focused on vehicles with good fuel efficiency based on your requirements. ");
⋮----
// Contextual follow-up cues
if (context.MentionedVehicleFeatures.Any())
⋮----
_ = response.Append(
⋮----
// Extract parameters from message using the Python parameter extraction service
⋮----
// Get the parameter extraction endpoint from configuration
⋮----
int timeoutSeconds = int.TryParse(_configuration["Services:ParameterExtraction:Timeout"], out int timeout)
⋮----
_logger.LogInformation("Calling parameter extraction service at {Endpoint}", endpoint);
⋮----
// Prepare the request
⋮----
StringContent content = new StringContent(
JsonSerializer.Serialize(request),
⋮----
// Configure timeout
CancellationTokenSource timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds));
⋮----
// Call the parameter extraction service
_logger.LogInformation("SENDING REQUEST to {Endpoint} with payload: {Query}", endpoint, message);
HttpResponseMessage response = await _httpClient.PostAsync(endpoint, content, timeoutCts.Token);
⋮----
string errorContent = await response.Content.ReadAsStringAsync();
⋮----
return new RecommendationParameters
⋮----
// Parse the response
string responseContent = await response.Content.ReadAsStringAsync();
_logger.LogDebug("Parameter extraction service response: {Response}", responseContent);
⋮----
using JsonDocument jsonDoc = JsonDocument.Parse(responseContent);
RecommendationParameters parameters = new RecommendationParameters
⋮----
// Parse numerical values safely
MinPrice = jsonDoc.RootElement.TryGetProperty("minPrice", out JsonElement minPriceElement) &&
⋮----
? minPriceElement.GetDecimal()
⋮----
MaxPrice = jsonDoc.RootElement.TryGetProperty("maxPrice", out JsonElement maxPriceElement) &&
⋮----
? maxPriceElement.GetDecimal()
⋮----
MinYear = jsonDoc.RootElement.TryGetProperty("minYear", out JsonElement minYearElement) &&
⋮----
? minYearElement.GetInt32()
⋮----
MaxYear = jsonDoc.RootElement.TryGetProperty("maxYear", out JsonElement maxYearElement) &&
⋮----
? maxYearElement.GetInt32()
⋮----
MaxMileage = jsonDoc.RootElement.TryGetProperty("maxMileage", out JsonElement mileageElement) &&
⋮----
? mileageElement.GetInt32()
⋮----
// Parse array values safely
PreferredMakes = jsonDoc.RootElement.TryGetProperty("preferredMakes", out JsonElement makesElement) &&
⋮----
? makesElement.EnumerateArray().Where(e => e.ValueKind == JsonValueKind.String)
.Select(e => e.GetString()).ToList()
⋮----
jsonDoc.RootElement.TryGetProperty("desiredFeatures", out JsonElement featuresElement) &&
⋮----
? featuresElement.EnumerateArray().Where(e => e.ValueKind == JsonValueKind.String)
⋮----
// Parse enums correctly
PreferredFuelTypes = jsonDoc.RootElement.TryGetProperty("preferredFuelTypes", out JsonElement fuelTypesElement) &&
⋮----
? fuelTypesElement.EnumerateArray()
.Where(e => e.ValueKind == JsonValueKind.String)
.Select(e => Enum.TryParse<FuelType>(e.GetString(), true, out FuelType fuel) ? fuel : (FuelType?)null)
.Where(f => f.HasValue)
.Select(f => f.Value)
.ToList()
⋮----
PreferredVehicleTypes = jsonDoc.RootElement.TryGetProperty("preferredVehicleTypes", out JsonElement vehicleTypesElement) &&
⋮----
? vehicleTypesElement.EnumerateArray()
⋮----
.Select(e =>
Enum.TryParse<VehicleType>(e.GetString(), true, out VehicleType vehicle) ? vehicle : (VehicleType?)null)
.Where(v => v.HasValue)
.Select(v => v.Value)
⋮----
// Validate the parameters
if (!RecommendationParameterValidator.Validate(parameters, out string? errorMessage))
⋮----
_logger.LogWarning("Parameter validation failed: {ErrorMessage}", errorMessage);
⋮----
// Parse the off-topic flags
parameters.IsOffTopic = jsonDoc.RootElement.TryGetProperty("isOffTopic", out JsonElement isOffTopicElement)
⋮----
if (parameters.IsOffTopic && jsonDoc.RootElement.TryGetProperty("offTopicResponse", out JsonElement responseElement)
⋮----
parameters.OffTopicResponse = responseElement.GetString();
⋮----
_logger.LogInformation("Final extracted parameters: {Params}", JsonSerializer.Serialize(parameters));
⋮----
_logger.LogError(ex, "Error extracting parameters from message");

================
File: Services/ConversationContextService.cs
================
public interface IConversationContextService
⋮----
Task<ConversationContext> GetOrCreateContextAsync(int userId);
⋮----
Task UpdateContextAsync(int userId, ConversationContext context);
⋮----
Task<ConversationSession> StartNewSessionAsync(int userId);
⋮----
Task<ConversationSession> GetCurrentSessionAsync(int userId);
⋮----
// This class represents the state we want to track throughout a conversation
public class ConversationContext
⋮----
// Current search parameters
⋮----
// Track conversation flow
⋮----
// Track user intent and context
⋮----
// Track active conversation topics
⋮----
// Track recommendations shown to the user
⋮----
// In-memory cache for active conversations (optional)
⋮----
// Check if we have an active session for the user
⋮----
// Check in-memory cache first for performance
if (_activeContexts.TryGetValue(userId, out ConversationContext? cachedContext))
⋮----
// Try to deserialize the context from the session
if (!string.IsNullOrEmpty(session.SessionContext))
⋮----
// Cache for subsequent requests
⋮----
_logger.LogError(ex, "Error deserializing conversation context for user {UserId}", userId);
⋮----
// Create a new context if we couldn't retrieve one
ConversationContext newContext = new ConversationContext
⋮----
// Start a new session if needed
⋮----
// Cache and return the new context
⋮----
_logger.LogError(ex, "Error retrieving conversation context for user {UserId}", userId);
return new ConversationContext();
⋮----
// Update in-memory cache
⋮----
// Update the timestamp
⋮----
// Get the current session
⋮----
// Serialize and save the context
session.SessionContext = JsonSerializer.Serialize(context);
⋮----
_context.Entry(session).State = EntityState.Modified;
_ = await _context.SaveChangesAsync();
⋮----
_logger.LogError(ex, "Error updating conversation context for user {UserId}", userId);
⋮----
ConversationSession newSession = new ConversationSession
⋮----
SessionContext = JsonSerializer.Serialize(new ConversationContext()),
⋮----
_ = _context.ConversationSessions.Add(newSession);
⋮----
// Clear any cached context
_ = _activeContexts.Remove(userId);
⋮----
// Get the most recent active session (less than 30 minutes old)
DateTime thirtyMinutesAgo = DateTime.UtcNow.AddMinutes(-30);
⋮----
.Where(s => s.UserId == userId && s.LastInteractionAt > thirtyMinutesAgo)
.OrderByDescending(s => s.LastInteractionAt)
.FirstOrDefaultAsync();

================
File: Services/HuggingFaceRecommendationsService.cs
================
_logger.LogInformation(
⋮----
userId, JsonSerializer.Serialize(parameters));
⋮----
// Log the important parameter values we'll be filtering on
⋮----
parameters.PreferredMakes != null ? string.Join(", ", parameters.PreferredMakes) : "null",
parameters.PreferredFuelTypes != null ? string.Join(", ", parameters.PreferredFuelTypes) : "null",
⋮----
? string.Join(", ", parameters.PreferredVehicleTypes)
⋮----
if (!filteredVehicles.Any())
⋮----
_logger.LogWarning("No available vehicles found for filtering criteria.");
⋮----
.OrderByDescending(v => v.DateListed)
.Take(parameters.MaxResults ?? 5)
.ToList();
⋮----
_logger.LogInformation("Returning {Count} vehicles based on parameter filtering", filteredVehicles.Count);
⋮----
// Log the actual results for debugging
foreach (Vehicle? vehicle in filteredVehicles.Take(5))
⋮----
_logger.LogError(ex, "Error retrieving recommendations for user ID {UserId}", userId);
⋮----
IQueryable<Vehicle> query = _context.Vehicles.AsQueryable();
⋮----
query = query.Where(v => v.Price >= parameters.MinPrice.Value);
⋮----
query = query.Where(v => v.Price <= parameters.MaxPrice.Value);
⋮----
query = query.Where(v => v.Year >= parameters.MinYear.Value);
⋮----
query = query.Where(v => v.Year <= parameters.MaxYear.Value);
⋮----
query = query.Where(v => v.Mileage <= parameters.MaxMileage.Value);
⋮----
string.Join(", ", parameters.PreferredVehicleTypes));
⋮----
// We can use the enum values directly since they're already parsed
query = query.Where(v => parameters.PreferredVehicleTypes.Contains(v.VehicleType));
⋮----
string.Join(", ", parameters.PreferredFuelTypes));
⋮----
query = query.Where(v => parameters.PreferredFuelTypes.Contains(v.FuelType));
⋮----
string.Join(", ", parameters.PreferredMakes));
⋮----
// Make case-insensitive comparison
List<string> lowerMakes = parameters.PreferredMakes.Select(m => m.ToLower(System.Globalization.CultureInfo.CurrentCulture)).ToList();
query = query.Where(v => lowerMakes.Contains(v.Make.ToLower(System.Globalization.CultureInfo.CurrentCulture)));
⋮----
string.Join(", ", parameters.DesiredFeatures));
⋮----
.Select(f => f.ToLowerInvariant())
.ToHashSet();
⋮----
.Select(v => new
⋮----
MatchCount = v.Features.Count(f => featureSet.Contains(f.Name.ToLower(System.Globalization.CultureInfo.CurrentCulture))),
⋮----
.OrderByDescending(v => v.MatchCount)
.ThenBy(v => v.Vehicle.Price) // Optional: add tie-breakers like price
.Select(v => v.Vehicle);
⋮----
query = query.Where(v => v.Status == VehicleStatus.Available)
.Include(v => v.Features)
.Include(v => v.Images);
⋮----
_logger.LogInformation("SQL Query: {Query}", query.ToQueryString());
⋮----
return await query.ToListAsync();

================
File: Services/RecommendationParameters.cs
================
// Parameter class to pass user preferences and context to the recommendation service
public class RecommendationParameters
⋮----
public string? TextPrompt { get; set; } // Add text prompt field
⋮----
public int? MaxResults { get; set; } = 5; // Default to 5 recommendations
⋮----
// Interface for any AI recommendation service (allows easy swapping)
public interface IAIRecommendationService
⋮----
Task<IEnumerable<Vehicle>> GetRecommendationsAsync(int userId, RecommendationParameters parameters);

================
File: Validators/RecommendationParameterValidator.cs
================
public static class RecommendationParameterValidator
⋮----
public static bool Validate(RecommendationParameters parameters, out string errorMessage)
⋮----
// Check if FuelType values are valid
⋮----
// Skip null values
⋮----
// Check if the value is a valid enum
if (!Enum.IsDefined(typeof(FuelType), fuelType))
⋮----
invalidFuelTypes.Add(fuelType.ToString());
⋮----
validatedFuelTypes.Add(fuelType);
⋮----
// If there are invalid fuel types, report them
if (invalidFuelTypes.Any())
⋮----
$"Invalid FuelType values: {string.Join(", ", invalidFuelTypes)}. Valid options are: {string.Join(", ", Enum.GetNames(typeof(FuelType)))}";
⋮----
// Replace the list with validated values
⋮----
// Check if VehicleType values are valid
⋮----
if (!Enum.IsDefined(typeof(VehicleType), vehicleType))
⋮----
invalidVehicleTypes.Add(vehicleType.ToString());
⋮----
validatedVehicleTypes.Add(vehicleType);
⋮----
// If there are invalid vehicle types, report them
if (invalidVehicleTypes.Any())
⋮----
$"Invalid VehicleType values: {string.Join(", ", invalidVehicleTypes)}. Valid options are: {string.Join(", ", Enum.GetNames(typeof(VehicleType)))}";
⋮----
// Validate price range
⋮----
// Validate year range

================
File: Program.cs
================
WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
⋮----
// Add services to the container
builder.Services.AddControllers();
⋮----
builder.Services.AddMemoryCache();
⋮----
// Configure SQLite
⋮----
options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));
⋮----
// Configure Authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
.AddJwtBearer(options =>
⋮----
options.TokenValidationParameters = new TokenValidationParameters
⋮----
IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"])),
⋮----
// Register services
⋮----
builder.Services.AddHttpClient(); // For HttpClient
builder.Services.AddAIRecommendationServices(builder.Configuration);
⋮----
builder.Services.AddControllers()
.AddJsonOptions(options =>
⋮----
options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
⋮----
// Configure CORS
builder.Services.AddCors(options =>
⋮----
options.AddPolicy("AllowFrontend", policy =>
⋮----
_ = policy.WithOrigins("http://localhost:5173")
.AllowAnyMethod()
.AllowAnyHeader()
.AllowCredentials();
⋮----
// Ensure Logs folder exists
Directory.CreateDirectory("Logs");
⋮----
// Configure logging
builder.Logging.ClearProviders();
builder.Logging.AddConsole();
builder.Logging.AddDebug();
builder.Logging.AddZLoggerFile("Logs/app_log.txt");
⋮----
// Configure Swagger
builder.Services.AddEndpointsApiExplorer();
⋮----
// Add this in your services configuration section
builder.Services.AddSwaggerGen(options =>
⋮----
options.SwaggerDoc("v1", new OpenApiInfo { Title = "Smart Auto Trader API", Version = "v1" });
⋮----
// Define the JWT Bearer authentication scheme
options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
⋮----
options.AddSecurityRequirement(new OpenApiSecurityRequirement
⋮----
new OpenApiSecurityScheme
⋮----
Reference = new OpenApiReference
⋮----
WebApplication app = builder.Build();
⋮----
// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
⋮----
_ = app.UseSwagger();
_ = app.UseSwaggerUI();
⋮----
app.UseCors("AllowFrontend");
app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
⋮----
app.MapControllers();
app.UseStaticFiles();
⋮----
// Create the database if it doesn't exist
using (IServiceScope scope = app.Services.CreateScope())
⋮----
IServiceProvider services = scope.ServiceProvider;
ApplicationDbContext context = services.GetRequiredService<ApplicationDbContext>();
_ = context.Database.EnsureCreated();
VehicleSeeder vehicleSeeder = services.GetRequiredService<VehicleSeeder>();
vehicleSeeder.SeedVehicles(services);
⋮----
app.Run();



================================================================
End of Codebase
================================================================
